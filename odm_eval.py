import numpy as np
import matplotlib.pyplot as pyplot
import rasterio as rio
import pandas as pd
import os
from GCP import convert_coordinate_UTM
from writer import save_image, save_data
import json
import time



'''
TODO - use indexing to get 1x1 m box with additional statistics


'''

class MiniArea:
    def __init__(self, ODM_object,x, y, size=10):
        print(x,y)
        self.pixel_length_x, self.pixel_length_y = ODM_object.x_pixel_len, ODM_object.y_pixel_len
        rows, cols = int(size // self.pixel_length_y), int(size // self.pixel_length_x)
        print(f'{rows =}{cols=}')
        row_min, row_max, col_min, col_max = y-rows//2, y+rows//2,x-cols//2,x+cols//2
        print(row_min, row_max, col_min, col_max)
        matrix_mini_area = np.asarray(ODM_object.canopy_model)
        
        self.matrix_mini_area = matrix_mini_area[row_min:row_max, col_min:col_max]
        print(self.matrix_mini_area.shape)


class ODMEval:
    def __init__(self, project_location, save=False):
        self.project_location = project_location
        self.scrap_project_data()
        if save:
            self.save()
        #self.show_orthophoto()
        print('volume = ', self.find_volume())
          
    # returns array of sizeXsize around the gps_x,gps_y point in orthophoto
    def mini_area(self,gps_x, gps_y, size=10):
        x,y = self.index_to_pixel(gps_x, gps_y) 
        return MiniArea(self, x,y)        


    # for subtracting canopy models to see growth 
    def __sub__(self, other):
        row, col = self.canopy_model.shape    
        row_other, col_other = other.canopy_model.shape

        subtracted = np.zeros((row,col))
         
        for r in range(row):
            for c in range(col):
                # covert row, col to its gps coordinate
                x_coor, y_coor  = self.index_to_coordinate(r,c) 
                # use gps coordinate to find related row,col in other 
                r_other, c_other = other.index_to_pixel(x_coor, y_coor)
                # check if col, row actually is in image
                if r_other >= 0 and r_other < row_other and c_other >= 0 and c_other < col_other:
                    # check if either value is nan
                    subtracted[r,c] = self.canopy_model[r][c] - other.canopy_model[r_other][c_other]
                else:
                    subtracted[r,c] = np.nan
         
        return subtracted



    # returns row, col pixels relating to specific coordinate x,y 
    def index_to_pixel(self, x,y):
        return rio.transform.rowcol(self.affine, x, y)[::-1] # returns col, row so invert for user simplicity

    # return coordinate relating to specific pixel xy, inverse of index func
    def index_to_coordinate(self, x,y):
        return self.affine * (x,y) 

    def save(self):
        # save the masked versions of dsm and dtm since normal tif version is not easily readable
        print('Saving Tiffs as jpgs for human readability')
        save_image(self.dsm, 'masked_dsm.jpg', self.project_location)
        save_image(self.dtm, 'masked_dtm.jpg', self.project_location)
        print('Saving canopy model')
        save_image(self.canopy_model, 'canopy.jpg', self.project_location)


    # get all data from project:
    def scrap_project_data(self):
        print('Getting data generated by the ODM')
        dsm_path = self.project_location + '/odm_dem/dsm.tif'
        dtm_path = self.project_location + '/odm_dem/dtm.tif'
        ortho_path = self.project_location + '/odm_orthophoto/odm_orthophoto.tif'

        # ortho transform higher precision than dem transform 
        with rio.open(ortho_path) as ortho:
            # affine is used to transform from pixel x,y to coorinate system and back
            self.affine = ortho.transform

            # 0,4 are locations of pixel size in affine according to
            #https://gis.stackexchange.com/questions/243639/how-to-take-cell-size-from-raster-using-python-or-gdal-or-rasterio
            self.x_pixel_len = self.affine[0]
            self.y_pixel_len = -self.affine[4]

        with rio.open(dsm_path) as dsm_dataset:
            with rio.open(dtm_path) as dtm_dataset:
                assert dsm_dataset.bounds == dtm_dataset.bounds

                self.bounds = dsm_dataset.bounds
                # read the dsm_dataset into np array form
                # use read(1) since shape is (1, x, y) read(1) causes output to be (x,y) removing need for a reshape
                self.dsm = dsm_dataset.read(1, masked=True)  # masked makes unknown data NaN instead of -9999, if not used causes strange looking picture
                self.dtm = dtm_dataset.read(1, masked=True)

                # find the element by element difference of the models to detect object heights
                print('Creating canopy model', flush=True)
                self.canopy_model = self.dsm - self.dtm


    def find_volume(self):
        # check if volume has already been calculated
        try:
            
            json_location = self.project_location + '/python_output/odm_output.txt'
            with open(json_location) as j_file:
                print('found odm_output json file, scraping found data')
                data = json.load(j_file)
            self.volume = data['volume']
            self.area_of_pixel = data['area_of_pixel']
            self.base_area = data['base_area']
            return self.volume

        except FileNotFoundError:
            print('Calculating volume of GeoTiff, may take a some time', flush=True)
            # ordering of bounds tuple is 0 left, 1 bottom, 2 right, 3 top
            width = self.bounds[2]- self.bounds[0]
            length = self.bounds[3] - self.bounds[1]

            print(self.canopy_model.shape) 
            width_pixels, length_pixels = self.canopy_model.shape
            
            sum_pixel_height = 0
            num_good_values = 0
            for row in self.canopy_model:
                for item in row:
                    # checks for nonexistent values
                    if not np.ma.is_masked(item):
                        # count number of good tiles to find actual area used
                        num_good_values += 1
                        #
                        sum_pixel_height += item

            # area of each individual pixel = total area / # of pixels
            area_of_pixel = (width* length) / (width_pixels * length_pixels)

            print('num of good pixels =', num_good_values)
            print(f'{sum_pixel_height=}, {area_of_pixel=}')
            print(f'area of base, area ={num_good_values*area_of_pixel}, num of valid pixels = {num_good_values}', flush=True)
            '''
            VOLUME = area_of_pixel * sum_pixel_height
            area_of_pixel = (metric_length*metric_height) / (num_length_pixel *num_width_pixel)
            '''
            self.area_of_pixel = area_of_pixel
            self.volume = sum_pixel_height * area_of_pixel
            self.base_area = num_good_values*area_of_pixel



            # send data to writer to be saved
            data_dict ={}
            data_dict['area_of_pixel'] = self.area_of_pixel
            data_dict['base_area'] = self.base_area
            data_dict['valid_pixels'] = num_good_values
            data_dict['volume'] = self.volume

            save_data(data_dict, self.project_location)

            return self.volume


    # shows orthophoto with gcp plotted
    def show_orthophoto(self):
        files = os.listdir(self.project_location)
        if 'gcp_list.txt' not in files:
            print('no GCP file to compare with')
            return -1
        unique_GCP = [] 
        gcp_location = self.project_location + '/gcp_list.txt'
        with open(gcp_location, 'r') as gcp:
            Lines = gcp.readlines()
            # first line is identification string so remove
            utm_string = Lines.pop(0)
            for line in Lines:
                # split line on spaces
                splits = line.split()
                # first two items are the coordinates
                x,y  = splits[0], splits[1]
                if (x,y) not in unique_GCP:
                    # if x,y pair first of its kind then append to list, convert from string to float for indexing later
                    unique_GCP.append((float(x),float(y)))
        # unique GCP is a list of all unique GCP that should be in orthophoto


        orthophoto_path = self.project_location + '/odm_orthophoto/odm_orthophoto.tif'
        img = rio.open(orthophoto_path)

        x_val, y_val = [], []
        for gcp in unique_GCP:
            # index converts the coordinate to pixel value in the given picture
            x_pix, y_pix = self.index_to_pixel(gcp[0], gcp[1])
            x_val.append(x_pix)
            y_val.append(y_pix)
       
        # convert rasterio img to np array
        arr = img.read()
        arr = arr[:3]
        # move color layer to the back
        # before change is 3,l,w needs to be l,w,3
        rgb_arr = np.transpose(arr, (1,2,0))
        pyplot.imshow(rgb_arr)
        # note pyplot inverts axis here so must feed it y,x instead of x,y
        pyplot.plot(x_val, y_val, '.', color='red')
        #pyplot.savefig(self.locations['project_location']+'/python_output/orthophoto.jpg')
        pyplot.show()

if __name__ == '__main__':
    loc = 'C:/Users/Hypnotic/Desktop/ODM/Unit_020_D'
    odm_pre = ODMEval(loc)
    x,y = odm_pre.index_to_coordinate(3000,3000)
    mini_area = odm_pre.mini_area(x,y)

